# NGINX location blocks for Kubernetes services
# Generated at: 2025-07-20 15:25:09.995003
# Total locations: 29
# Add these inside your server block

location /cert-manager_cert-manager_9402 {
            set $base_path "/cert-manager_cert-manager_9402";
            rewrite ^/cert-manager_cert-manager_9402/?(.*)$ /$1 break;
            proxy_pass http://cert-manager.cert-manager.svc.cluster.local:9402;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /cert-manager_cert-manager-cainjector_9402 {
            set $base_path "/cert-manager_cert-manager-cainjector_9402";
            rewrite ^/cert-manager_cert-manager-cainjector_9402/?(.*)$ /$1 break;
            proxy_pass http://cert-manager-cainjector.cert-manager.svc.cluster.local:9402;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /cert-manager_cert-manager-webhook_443 {
            set $base_path "/cert-manager_cert-manager-webhook_443";
            rewrite ^/cert-manager_cert-manager-webhook_443/?(.*)$ /$1 break;
            proxy_pass http://cert-manager-webhook.cert-manager.svc.cluster.local:443;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /cert-manager_cert-manager-webhook_9402 {
            set $base_path "/cert-manager_cert-manager-webhook_9402";
            rewrite ^/cert-manager_cert-manager-webhook_9402/?(.*)$ /$1 break;
            proxy_pass http://cert-manager-webhook.cert-manager.svc.cluster.local:9402;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /default_kubernetes_443 {
            set $base_path "/default_kubernetes_443";
            rewrite ^/default_kubernetes_443/?(.*)$ /$1 break;
            proxy_pass http://kubernetes.default.svc.cluster.local:443;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /ingress-nginx_ingress-nginx-controller_80 {
            set $base_path "/ingress-nginx_ingress-nginx-controller_80";
            rewrite ^/ingress-nginx_ingress-nginx-controller_80/?(.*)$ /$1 break;
            proxy_pass http://ingress-nginx-controller.ingress-nginx.svc.cluster.local:80;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /ingress-nginx_ingress-nginx-controller_443 {
            set $base_path "/ingress-nginx_ingress-nginx-controller_443";
            rewrite ^/ingress-nginx_ingress-nginx-controller_443/?(.*)$ /$1 break;
            proxy_pass http://ingress-nginx-controller.ingress-nginx.svc.cluster.local:443;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /ingress-nginx_ingress-nginx-controller-admission_443 {
            set $base_path "/ingress-nginx_ingress-nginx-controller-admission_443";
            rewrite ^/ingress-nginx_ingress-nginx-controller-admission_443/?(.*)$ /$1 break;
            proxy_pass http://ingress-nginx-controller-admission.ingress-nginx.svc.cluster.local:443;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /ingress-nginx_ingress-nginx-controller-metrics_10254 {
            set $base_path "/ingress-nginx_ingress-nginx-controller-metrics_10254";
            rewrite ^/ingress-nginx_ingress-nginx-controller-metrics_10254/?(.*)$ /$1 break;
            proxy_pass http://ingress-nginx-controller-metrics.ingress-nginx.svc.cluster.local:10254;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /k8s-service-proxy_k8s-service-proxy_7070 {
            set $base_path "/k8s-service-proxy_k8s-service-proxy_7070";
            rewrite ^/k8s-service-proxy_k8s-service-proxy_7070/?(.*)$ /$1 break;
            proxy_pass http://k8s-service-proxy.k8s-service-proxy.svc.cluster.local:7070;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /kc28_kc28-aggregator_9004 {
            set $base_path "/kc28_kc28-aggregator_9004";
            rewrite ^/kc28_kc28-aggregator_9004/?(.*)$ /$1 break;
            proxy_pass http://kc28-aggregator.kc28.svc.cluster.local:9004;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /kc28_kc28-cloud-cost_9005 {
            set $base_path "/kc28_kc28-cloud-cost_9005";
            rewrite ^/kc28_kc28-cloud-cost_9005/?(.*)$ /$1 break;
            proxy_pass http://kc28-cloud-cost.kc28.svc.cluster.local:9005;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /kc28_kc28-cost-analyzer_9003 {
            set $base_path "/kc28_kc28-cost-analyzer_9003";
            rewrite ^/kc28_kc28-cost-analyzer_9003/?(.*)$ /$1 break;
            proxy_pass http://kc28-cost-analyzer.kc28.svc.cluster.local:9003;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /kc28_kc28-frontend_9090 {
            set $base_path "/kc28_kc28-frontend_9090";
            rewrite ^/kc28_kc28-frontend_9090/?(.*)$ /$1 break;
            proxy_pass http://kc28-frontend.kc28.svc.cluster.local:9090;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /kc28ch_kc28ch-aggregator_9004 {
            set $base_path "/kc28ch_kc28ch-aggregator_9004";
            rewrite ^/kc28ch_kc28ch-aggregator_9004/?(.*)$ /$1 break;
            proxy_pass http://kc28ch-aggregator.kc28ch.svc.cluster.local:9004;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /kc28ch_kc28ch-cost-analyzer_9003 {
            set $base_path "/kc28ch_kc28ch-cost-analyzer_9003";
            rewrite ^/kc28ch_kc28ch-cost-analyzer_9003/?(.*)$ /$1 break;
            proxy_pass http://kc28ch-cost-analyzer.kc28ch.svc.cluster.local:9003;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /kc28ch_kc28ch-frontend_9090 {
            set $base_path "/kc28ch_kc28ch-frontend_9090";
            rewrite ^/kc28ch_kc28ch-frontend_9090/?(.*)$ /$1 break;
            proxy_pass http://kc28ch-frontend.kc28ch.svc.cluster.local:9090;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /kc30_kc30-aggregator_9004 {
            set $base_path "/kc30_kc30-aggregator_9004";
            rewrite ^/kc30_kc30-aggregator_9004/?(.*)$ /$1 break;
            proxy_pass http://kc30-aggregator.kc30.svc.cluster.local:9004;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /kc30_kc30-frontend_9090 {
            set $base_path "/kc30_kc30-frontend_9090";
            rewrite ^/kc30_kc30-frontend_9090/?(.*)$ /$1 break;
            proxy_pass http://kc30-frontend.kc30.svc.cluster.local:9090;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /kubetail-system_kubetail-cluster-api_8080 {
            set $base_path "/kubetail-system_kubetail-cluster-api_8080";
            rewrite ^/kubetail-system_kubetail-cluster-api_8080/?(.*)$ /$1 break;
            proxy_pass http://kubetail-cluster-api.kubetail-system.svc.cluster.local:8080;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /monitoring_kube-prometheus-stack-alertmanager_9093 {
            set $base_path "/monitoring_kube-prometheus-stack-alertmanager_9093";
            rewrite ^/monitoring_kube-prometheus-stack-alertmanager_9093/?(.*)$ /$1 break;
            proxy_pass http://kube-prometheus-stack-alertmanager.monitoring.svc.cluster.local:9093;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /monitoring_kube-prometheus-stack-alertmanager_8080 {
            set $base_path "/monitoring_kube-prometheus-stack-alertmanager_8080";
            rewrite ^/monitoring_kube-prometheus-stack-alertmanager_8080/?(.*)$ /$1 break;
            proxy_pass http://kube-prometheus-stack-alertmanager.monitoring.svc.cluster.local:8080;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /monitoring_kube-prometheus-stack-grafana_80 {
            set $base_path "/monitoring_kube-prometheus-stack-grafana_80";
            rewrite ^/monitoring_kube-prometheus-stack-grafana_80/?(.*)$ /$1 break;
            proxy_pass http://kube-prometheus-stack-grafana.monitoring.svc.cluster.local:80;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /monitoring_kube-prometheus-stack-kube-state-metrics_8080 {
            set $base_path "/monitoring_kube-prometheus-stack-kube-state-metrics_8080";
            rewrite ^/monitoring_kube-prometheus-stack-kube-state-metrics_8080/?(.*)$ /$1 break;
            proxy_pass http://kube-prometheus-stack-kube-state-metrics.monitoring.svc.cluster.local:8080;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /monitoring_kube-prometheus-stack-operator_443 {
            set $base_path "/monitoring_kube-prometheus-stack-operator_443";
            rewrite ^/monitoring_kube-prometheus-stack-operator_443/?(.*)$ /$1 break;
            proxy_pass http://kube-prometheus-stack-operator.monitoring.svc.cluster.local:443;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /monitoring_kube-prometheus-stack-prometheus_9090 {
            set $base_path "/monitoring_kube-prometheus-stack-prometheus_9090";
            rewrite ^/monitoring_kube-prometheus-stack-prometheus_9090/?(.*)$ /$1 break;
            proxy_pass http://kube-prometheus-stack-prometheus.monitoring.svc.cluster.local:9090;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /monitoring_kube-prometheus-stack-prometheus_8080 {
            set $base_path "/monitoring_kube-prometheus-stack-prometheus_8080";
            rewrite ^/monitoring_kube-prometheus-stack-prometheus_8080/?(.*)$ /$1 break;
            proxy_pass http://kube-prometheus-stack-prometheus.monitoring.svc.cluster.local:8080;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /monitoring_kube-prometheus-stack-prometheus-node-exporter_9100 {
            set $base_path "/monitoring_kube-prometheus-stack-prometheus-node-exporter_9100";
            rewrite ^/monitoring_kube-prometheus-stack-prometheus-node-exporter_9100/?(.*)$ /$1 break;
            proxy_pass http://kube-prometheus-stack-prometheus-node-exporter.monitoring.svc.cluster.local:9100;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

location /nginx-router_nginx-router_8080 {
            set $base_path "/nginx-router_nginx-router_8080";
            rewrite ^/nginx-router_nginx-router_8080/?(.*)$ /$1 break;
            proxy_pass http://nginx-router.nginx-router.svc.cluster.local:8080;

            # Handle redirects by returning the location header as plain text
            proxy_hide_header Location;
            add_header X-Original-Location $upstream_http_location;
            add_header X-Original-Status $upstream_status;
            
            # If it's a 302, return the location as the response body
            # TODO: This is a hack to handle redirects. We should find a better way to handle this.
            if ($upstream_status = 302) {
                return 200 $upstream_http_location;
            }

            # Standard proxy headers
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            
            # Timeout settings
            proxy_connect_timeout 30s;
            proxy_send_timeout 30s;
            proxy_read_timeout 30s;
        }

