<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Porthole - Kubernetes Services Portal</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', sans-serif;
            background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%);
            color: #e0e0e0;
            line-height: 1.6;
            min-height: 100vh;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, #2d2d2d 0%, #3a3a3a 100%);
            padding: 1.5rem 1rem;
            border-bottom: 3px solid #64b5f6;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        h1 {
            color: #ffffff;
            text-align: center;
            font-size: 2rem;
            font-weight: 300;
            margin-bottom: 0.75rem;
        }

        .header-nav {
            display: flex;
            justify-content: center;
            gap: 1rem;
            flex-wrap: wrap;
            margin-top: 0.75rem;
            align-items: center;
        }

        /* Advanced Filter */
        .advanced-filter {
            position: relative;
            display: inline-block;
            margin-right: 1rem;
        }

        .filter-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            color: #ffffff;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 200px;
            /* Wider to allow more text on single line */
            justify-content: space-between;
        }

        .filter-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .filter-button.active {
            background: rgba(100, 181, 246, 0.3);
            border-color: #64b5f6;
        }

        .filter-button::after {
            content: 'üîç';
            font-size: 0.8rem;
        }

        .filter-active-count {
            background: #64b5f6;
            color: white;
            font-size: 0.7rem;
            padding: 0.1rem 0.4rem;
            border-radius: 10px;
            margin-left: 0.5rem;
        }

        .filter-panel {
            position: absolute;
            top: 100%;
            left: 0;
            background: rgba(45, 45, 45, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 1px;
            padding: 1rem;
            min-width: 400px;
            z-index: 100;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: none;
        }

        .filter-panel.show {
            display: block;
        }

        .filter-panel h3 {
            color: #ffffff;
            margin-bottom: 0.75rem;
            font-size: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 0.5rem;
        }

        .filter-rule {
            display: flex;
            gap: 0.75rem;
            margin-bottom: 1rem;
            align-items: center;
            flex-wrap: nowrap;
        }

        .filter-rule select,
        .filter-rule input {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 0.75rem 1rem;
            color: #ffffff;
            font-size: 1rem;
            transition: all 0.2s ease;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .filter-rule select:focus,
        .filter-rule input:focus {
            background: rgba(255, 255, 255, 0.15);
            border-color: #64b5f6;
            outline: none;
            box-shadow: 0 0 0 3px rgba(100, 181, 246, 0.3), 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .filter-rule select {
            min-width: 140px;
            max-width: 160px;
            font-weight: 500;
        }

        .filter-rule input {
            flex: 1;
            min-width: 200px;
            position: relative;
        }

        .filter-rule input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .filter-rule-remove {
            background: rgba(244, 67, 54, 0.2);
            border: 2px solid rgba(244, 67, 54, 0.3);
            border-radius: 6px;
            color: #f44336;
            cursor: pointer;
            padding: 0.4rem 0.6rem;
            font-size: 0.8rem;
            transition: all 0.2s ease;
            min-width: 32px;
            text-align: center;
        }

        .filter-rule-remove:hover {
            background: rgba(244, 67, 54, 0.3);
            border-color: rgba(244, 67, 54, 0.5);
            box-shadow: 0 2px 4px rgba(244, 67, 54, 0.2);
        }

        .filter-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid rgba(255, 255, 255, 0.2);
        }

        .filter-add-rule,
        .filter-clear-all {
            background: rgba(100, 181, 246, 0.2);
            border: 2px solid rgba(100, 181, 246, 0.3);
            border-radius: 8px;
            color: #64b5f6;
            cursor: pointer;
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
            transition: all 0.2s ease;
            font-weight: 500;
        }

        .filter-add-rule:hover,
        .filter-clear-all:hover {
            background: rgba(100, 181, 246, 0.3);
            border-color: rgba(100, 181, 246, 0.5);
            box-shadow: 0 2px 8px rgba(100, 181, 246, 0.2);
        }

        .filter-clear-all {
            background: rgba(255, 152, 0, 0.2);
            border-color: rgba(255, 152, 0, 0.3);
            color: #ff9800;
        }

        .filter-clear-all:hover {
            background: rgba(255, 152, 0, 0.3);
            border-color: rgba(255, 152, 0, 0.5);
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.2);
        }

        .filter-logic {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            font-size: 0.8rem;
            color: #b0b0b0;
            margin: 0;
            min-width: 80px;
        }

        .filter-logic select {
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            padding: 0.3rem 0.5rem;
            color: #ffffff;
            font-size: 0.8rem;
            transition: all 0.2s ease;
        }

        .filter-logic select:focus {
            background: rgba(255, 255, 255, 0.15);
            border-color: #64b5f6;
            outline: none;
            box-shadow: 0 0 0 2px rgba(100, 181, 246, 0.3);
        }

        /* Autocomplete Styles */
        .autocomplete-container {
            position: relative;
            flex: 1;
            min-width: 200px;
        }

        .autocomplete-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: rgba(45, 45, 45, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-top: none;
            border-radius: 0 0 6px 6px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1001;
            backdrop-filter: blur(10px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            display: none;
        }

        .autocomplete-suggestions.show {
            display: block;
        }

        .autocomplete-suggestion {
            padding: 0.75rem 1rem;
            color: #e0e0e0;
            cursor: pointer;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background-color 0.2s ease;
            font-size: 0.9rem;
        }

        .autocomplete-suggestion:last-child {
            border-bottom: none;
        }

        .autocomplete-suggestion:hover,
        .autocomplete-suggestion.highlighted {
            background: rgba(100, 181, 246, 0.2);
            color: #ffffff;
        }

        .autocomplete-suggestion.highlighted {
            background: rgba(100, 181, 246, 0.3);
        }

        .autocomplete-no-results {
            padding: 0.75rem 1rem;
            color: rgba(255, 255, 255, 0.5);
            font-style: italic;
            font-size: 0.9rem;
            text-align: center;
        }

        /* Namespace Dropdown */
        .namespace-dropdown {
            position: relative;
            display: inline-block;
            margin-right: auto;
        }

        .namespace-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 0.5rem 1rem;
            color: #ffffff;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            width: 450px;
            /* Wider to allow more text on single line */
            justify-content: space-between;
        }

        .namespace-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .namespace-button::after {
            content: '‚ñº';
            font-size: 0.8rem;
            transition: transform 0.2s ease;
        }

        .namespace-button.active::after {
            transform: rotate(180deg);
        }

        .namespace-selector {
            position: absolute;
            top: 100%;
            left: 0;
            background: rgba(45, 45, 45, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 1rem;
            min-width: 200px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: none;
        }

        .namespace-selector.show {
            display: block;
        }

        .namespace-selector h3 {
            color: #ffffff;
            margin-bottom: 0.75rem;
            font-size: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 0.5rem;
        }

        .namespace-search {
            margin-bottom: 0.75rem;
        }

        .namespace-search input {
            width: 100%;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 0.5rem 0.75rem;
            color: #ffffff;
            font-size: 0.9rem;
            transition: all 0.2s ease;
        }

        .namespace-search input:focus {
            background: rgba(255, 255, 255, 0.15);
            border-color: #64b5f6;
            outline: none;
            box-shadow: 0 0 0 3px rgba(100, 181, 246, 0.3);
        }

        .namespace-search input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .namespace-options {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .namespace-option {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.3rem 0.5rem;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .namespace-option:hover {
            background: rgba(100, 181, 246, 0.2);
        }

        .namespace-option.selected {
            background: rgba(100, 181, 246, 0.3);
            color: #64b5f6;
        }

        .namespace-option input[type="radio"] {
            width: 14px;
            height: 14px;
            accent-color: #64b5f6;
        }

        .namespace-option label {
            color: #e0e0e0;
            cursor: pointer;
            font-size: 0.85rem;
            flex: 1;
        }

        .namespace-option.selected label {
            color: #64b5f6;
            font-weight: 500;
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            padding: 0.4rem 1.2rem;
            border-radius: 12px;
            text-align: center;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 120px;
            flex: 1;
            max-width: 200px;
        }

        .stat-card:hover {
            background: rgba(100, 181, 246, 0.2);
            border-color: rgba(100, 181, 246, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(100, 181, 246, 0.3);
        }

        .stat-card.active {
            background: rgba(100, 181, 246, 0.3);
            border-color: #64b5f6;
        }

        .stat-value {
            font-size: 1.1rem;
            font-weight: bold;
            color: #64b5f6;
        }

        .stat-label {
            font-size: 0.7rem;
            color: #b0b0b0;
            margin-top: 0.2rem;
        }

        /* Cookie Clear Button */
        .cookie-clear-button {
            background: rgba(255, 152, 0, 0.2);
            border: 2px solid rgba(255, 152, 0, 0.3);
            border-radius: 8px;
            color: #ff9800;
            cursor: pointer;
            padding: 0.5rem 1rem;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .cookie-clear-button:hover {
            background: rgba(255, 152, 0, 0.3);
            border-color: rgba(255, 152, 0, 0.5);
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.2);
            transform: translateY(-1px);
        }

        .cookie-clear-button:active {
            transform: translateY(0);
        }

        /* Navigation */
        .navigation {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin: 1.5rem 0;
        }

        .nav-link {
            background: rgba(255, 255, 255, 0.1);
            color: #ffffff;
            padding: 0.5rem 1rem;
            border-radius: 8px;
            text-decoration: none;
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }

        .nav-link:hover,
        .nav-link.active {
            background: rgba(100, 181, 246, 0.2);
            border-color: #64b5f6;
        }

        /* Table Header with Hamburger Menu */
        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 1.5rem 1rem 0.5rem 1rem;
        }

        .table-title {
            color: #ffffff;
            font-size: 1.2rem;
            font-weight: 600;
        }

        .hamburger-menu {
            position: relative;
            display: inline-block;
        }

        .hamburger-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            padding: 0.5rem 0.75rem;
            color: #ffffff;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.2s ease;
        }

        .hamburger-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .field-selector {
            position: absolute;
            top: 100%;
            right: 0;
            background: rgba(45, 45, 45, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            padding: 1rem;
            min-width: 300px;
            z-index: 1000;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            display: none;
        }

        .field-selector.show {
            display: block;
        }

        .field-selector h3 {
            color: #ffffff;
            margin-bottom: 0.75rem;
            font-size: 1rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding-bottom: 0.5rem;
        }

        .field-checkboxes {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.4rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .field-checkbox {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .field-checkbox input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: #64b5f6;
        }

        .field-checkbox label {
            color: #e0e0e0;
            cursor: pointer;
            font-size: 0.85rem;
        }

        /* Table Styles */
        .table-container {
            margin: 0 1rem 1.5rem 1rem;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            overflow: hidden;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }

        table {
            width: 100%;
            border-collapse: collapse;
        }

        th {
            background: linear-gradient(135deg, #3a3a3a 0%, #4a4a4a 100%);
            color: #ffffff;
            padding: 0.75rem 0.5rem;
            text-align: left;
            font-weight: 600;
            border-bottom: 2px solid #64b5f6;
            font-size: 0.9rem;
        }

        td {
            padding: 0.5rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            transition: background-color 0.2s ease;
            font-size: 0.85rem;
        }

        tbody tr {
            cursor: pointer;
            transition: all 0.2s ease;
        }

        tbody tr:hover {
            background: rgba(100, 181, 246, 0.15);
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(100, 181, 246, 0.2);
        }

        tbody tr:nth-child(even) {
            background: rgba(255, 255, 255, 0.02);
        }

        tbody tr:nth-child(even):hover {
            background: rgba(100, 181, 246, 0.15);
        }

        .status-indicator {
            font-size: 1rem;
            margin-right: 0.25rem;
        }

        .frontend-true {
            color: #4caf50;
        }

        .endpoints-false {
            color: #f44336;
        }

        .endpoints-true {
            color: #4caf50;
        }

        /* HTTP Response Code Styles */
        .http-code-2xx {
            color: #4caf50;
            font-weight: 600;
        }

        .http-code-3xx {
            color: #ff9800;
            font-weight: 600;
        }

        .http-code-4xx,
        .http-code-5xx {
            color: #f44336;
            font-weight: 600;
        }

        .http-code-none {
            color: #9e9e9e;
            font-style: italic;
        }

        /* Loading */
        .loading {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 4px solid rgba(100, 181, 246, 0.3);
            border-top: 4px solid #64b5f6;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            h1 {
                font-size: 1.75rem;
            }

            .header-nav {
                gap: 0.5rem;
                flex-direction: column;
                align-items: stretch;
            }

            .advanced-filter {
                margin-right: 0;
                margin-bottom: 0.5rem;
            }

            .filter-button {
                width: 100%;
                justify-content: space-between;
            }

            .filter-panel {
                min-width: 100%;
                left: 0;
            }

            .filter-rule {
                flex-direction: column;
                align-items: stretch;
                gap: 0.5rem;
            }

            .filter-rule select,
            .filter-rule input {
                width: 100%;
                min-width: auto;
                max-width: none;
            }

            .filter-logic {
                min-width: auto;
                width: 100%;
            }

            .filter-logic select {
                width: 100%;
            }

            .autocomplete-container {
                min-width: auto;
            }

            .namespace-dropdown {
                margin-right: 0;
                margin-bottom: 0.5rem;
            }

            .namespace-button {
                width: 100%;
                justify-content: space-between;
            }

            .namespace-selector {
                min-width: 100%;
                left: 0;
            }

            .stat-card {
                padding: 0.3rem 0.8rem;
                min-width: 100px;
            }

            .cookie-clear-button {
                padding: 0.4rem 0.8rem;
                font-size: 0.8rem;
                width: 100%;
                justify-content: center;
                margin-top: 0.5rem;
            }

            .table-header {
                margin: 1rem 0.5rem 0.5rem 0.5rem;
            }

            .table-container {
                margin: 0 0.5rem 1rem 0.5rem;
                overflow-x: auto;
            }

            table {
                min-width: 600px;
            }

            th,
            td {
                padding: 0.4rem 0.3rem;
                font-size: 0.8rem;
            }

            .field-selector {
                min-width: 250px;
                right: -50px;
            }
        }

        /* Medium screens - single line layout */
        @media (min-width: 769px) and (max-width: 1200px) {
            .header-nav {
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
            }

            .advanced-filter {
                margin-right: 0.5rem;
                margin-bottom: 0;
            }

            .filter-panel {
                min-width: 500px;
            }

            .namespace-dropdown {
                margin-right: 0;
                margin-bottom: 0;
            }

            .namespace-button {
                width: auto;
                justify-content: space-between;
            }

            .stat-card {
                flex: 1;
                max-width: 150px;
            }
        }

        /* Large screens - optimized single line layout */
        @media (min-width: 1201px) {
            .header-nav {
                flex-direction: row;
                align-items: center;
                justify-content: space-between;
                gap: 1.5rem;
            }

            .advanced-filter {
                margin-right: 1rem;
                margin-bottom: 0;
            }

            .filter-panel {
                min-width: 600px;
            }

            .namespace-dropdown {
                margin-right: 0;
                margin-bottom: 0;
            }

            .namespace-button {
                width: auto;
                justify-content: space-between;
                min-width: 180px;
            }

            .stat-card {
                flex: 1;
                max-width: 180px;
            }
        }

        /* Hidden columns */
        .hidden {
            display: none;
        }

        /* Filtered rows */
        .filtered-out {
            display: none !important;
        }

    </style>
</head>

<body>
    <header>
        <div class="header-nav">
            <div class="advanced-filter">
                <button class="filter-button" onclick="toggleAdvancedFilter()">
                    Advanced Filter<span id="filter-active-count" class="filter-active-count"
                        style="display: none;">0</span>
                </button>
                <div class="filter-panel" id="advanced-filter-panel">
                    <h3>Advanced Filter</h3>
                    <div id="filter-rules"></div>
                    <div class="filter-actions">
                        <button class="filter-add-rule" onclick="addFilterRule()">+ Add Rule</button>
                        <button class="filter-clear-all" onclick="clearAllFilters()">Clear All</button>
                    </div>
                </div>
            </div>
            <div class="namespace-dropdown">
                <button class="namespace-button" onclick="toggleNamespaceSelector()">
                    Namespace: <span id="current-namespace">All</span>
                </button>
                <div class="namespace-selector" id="namespace-selector">
                    <h3>Select Namespace</h3>
                    <div class="namespace-search">
                        <input type="text" id="namespace-search-input" placeholder="Search namespaces..."
                            oninput="filterNamespaceOptions()" autocomplete="off">
                    </div>
                    <div class="namespace-options" id="namespace-options">
                        <div class="namespace-option selected">
                            <input type="radio" name="namespace" value="all" checked>
                            <label>All Namespaces</label>
                        </div>
                    </div>
                </div>
            </div>
            <div class="stat-card" data-filter="all" onclick="filterByStat('all')">
                <div class="stat-value" id="total-services">-</div>
                <div class="stat-label">All Services</div>
            </div>
            <div class="stat-card" data-filter="frontend" onclick="filterByStat('frontend')">
                <div class="stat-value" id="frontend-services">-</div>
                <div class="stat-label">Frontends</div>
            </div>
            <div class="stat-card" data-filter="healthy" onclick="filterByStat('healthy')">
                <div class="stat-value" id="healthy-services">-</div>
                <div class="stat-label">Healthy</div>
            </div>
            <div class="stat-card" data-filter="unhealthy" onclick="filterByStat('unhealthy')">
                <div class="stat-value" id="unhealthy-services">-</div>
                <div class="stat-label">Unhealthy</div>
            </div>
            <button class="cookie-clear-button" onclick="clearCookies()" title="Clear cookies for this domain">
                üç™ Clear Cookies
            </button>
        </div>
    </header>

    <div class="table-header">
        <div class="table-title">Service Details</div>
        <div class="hamburger-menu">
            <button class="hamburger-button" onclick="toggleFieldSelector()">‚ò∞</button>
            <div class="field-selector" id="field-selector">
                <h3>Select Fields to Display</h3>
                <div class="field-checkboxes">
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-all">
                        <label for="field-all"><strong>All Fields</strong></label>
                    </div>
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-namespace" checked>
                        <label for="field-namespace">Namespace</label>
                    </div>
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-service" checked>
                        <label for="field-service">Service</label>
                    </div>
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-port_name" checked>
                        <label for="field-port_name">Port Name</label>
                    </div>
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-http_response_code" checked>
                        <label for="field-http_response_code">HTTP Response Code</label>
                    </div>
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-redirect_url" checked>
                        <label for="field-redirect_url">Redirect Info</label>
                    </div>
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-port">
                        <label for="field-port">Port</label>
                    </div>
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-protocol">
                        <label for="field-protocol">Protocol</label>
                    </div>
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-service_type">
                        <label for="field-service_type">Service Type</label>
                    </div>
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-cluster_ip">
                        <label for="field-cluster_ip">Cluster IP</label>
                    </div>
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-endpoint_status">
                        <label for="field-endpoint_status">Endpoint Status</label>
                    </div>
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-is_frontend">
                        <label for="field-is_frontend">Is Frontend</label>
                    </div>
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-has_endpoints">
                        <label for="field-has_endpoints">Has Endpoints</label>
                    </div>
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-endpoint_count">
                        <label for="field-endpoint_count">Endpoint Count</label>
                    </div>
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-proxy_url">
                        <label for="field-proxy_url">Proxy URL</label>
                    </div>
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-display_name">
                        <label for="field-display_name">Display Name</label>
                    </div>
                    <div class="field-checkbox">
                        <input type="checkbox" id="field-created_at">
                        <label for="field-created_at">Created At</label>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="loading" class="loading">
        <div class="spinner"></div>
    </div>

    <div class="table-container" id="table-container" style="display: none;">
        <table>
            <thead>
                <tr>
                    <th class="col-status">Status</th>
                    <th class="col-namespace">Namespace</th>
                    <th class="col-service">Service</th>
                    <th class="col-port_name">Port Name</th>
                    <th class="col-http_response_code">HTTP Code</th>
                    <th class="col-redirect_url">Redirect Info</th>
                    <th class="col-port hidden">Port</th>
                    <th class="col-protocol hidden">Protocol</th>
                    <th class="col-service_type hidden">Service Type</th>
                    <th class="col-cluster_ip hidden">Cluster IP</th>
                    <th class="col-endpoint_status hidden">Endpoint Status</th>
                    <th class="col-is_frontend hidden">Is Frontend</th>
                    <th class="col-has_endpoints hidden">Has Endpoints</th>
                    <th class="col-endpoint_count hidden">Endpoint Count</th>
                    <th class="col-proxy_url hidden">Proxy URL</th>
                    <th class="col-display_name hidden">Display Name</th>
                    <th class="col-created_at hidden">Created At</th>
                </tr>
            </thead>
            <tbody id="table-body">
                <!-- Services will be loaded here -->
            </tbody>
        </table>
    </div>


    <script>
        let servicesData = null;
        let currentFilter = 'all';
        let currentNamespace = 'all';
        let advancedFilters = [];
        let filterRuleCounter = 0;

        // URL parameter utilities
        function getUrlParameter(name) {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get(name);
        }

        function setUrlParameter(name, value) {
            const url = new URL(window.location);
            if (value && value !== 'all') {
                url.searchParams.set(name, value);
            } else {
                url.searchParams.delete(name);
            }
            window.history.replaceState({}, '', url);
        }

        function updateUrlParameters() {
            if (currentFilter !== 'all') {
                setUrlParameter('filter', currentFilter);
            } else {
                setUrlParameter('filter', null);
            }

            if (currentNamespace !== 'all') {
                setUrlParameter('namespace', currentNamespace);
            } else {
                setUrlParameter('namespace', null);
            }
        }

        // Utility functions
        function formatDateTime(dateString) {
            if (!dateString) return '-';
            return new Date(dateString).toLocaleString();
        }

        function formatHttpResponseCode(code) {
            if (code === null || code === undefined) {
                return '<span class="http-code-none">No Response</span>';
            }

            let className = 'http-code-none';
            if (code >= 200 && code < 300) {
                className = 'http-code-2xx';
            } else if (code >= 300 && code < 400) {
                className = 'http-code-3xx';
            } else if (code >= 400 && code < 500) {
                className = 'http-code-4xx';
            } else if (code >= 500) {
                className = 'http-code-5xx';
            }

            return `<span class="${className}">${code}</span>`;
        }

        // Load services data
        async function loadServicesData() {
            try {
                const response = await fetch('services.json');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                servicesData = await response.json();
                updateUI();
                renderTable();
                setupFieldSelector();
                setupNamespaceSelector();
                setupAdvancedFilter();

                // Apply URL parameters after setup
                applyUrlParameters();
                loadAdvancedFiltersFromUrl();
            } catch (error) {
                console.error('Failed to load services data:', error);
                document.getElementById('loading').innerHTML = '<p>Failed to load services data. Please check if services.json exists.</p>';
            }
        }

        // Update header stats
        function updateUI() {
            if (!servicesData || !servicesData.meta) return;

            const meta = servicesData.meta;

            document.getElementById('total-services').textContent = meta.total_services || 0;
            document.getElementById('healthy-services').textContent = meta.healthy_services || 0;
            document.getElementById('unhealthy-services').textContent = meta.unhealthy_services || 0;
            document.getElementById('frontend-services').textContent = meta.frontend_services || 0;
        }

        // Render table
        function renderTable() {
            if (!servicesData || !servicesData.services) return;

            const tableBody = document.getElementById('table-body');
            let html = '';

            servicesData.services.forEach(service => {
                const statusIndicator = getStatusIndicator(service);

                html += `
                    <tr data-proxy-url="${service.proxy_url}" 
                        data-endpoint-status="${service.endpoint_status}"
                        data-is-frontend="${service.is_frontend}"
                        data-namespace="${service.namespace}"
                        data-redirect-url="${service.redirect_url || ''}"
                        onclick="openService('${service.proxy_url}', '${service.redirect_url || ''}')">
                        <td class="col-status">${statusIndicator}</td>
                        <td class="col-namespace">${service.namespace}</td>
                        <td class="col-service">${service.service}</td>
                        <td class="col-port_name">${service.port_name || 'N/A'}</td>
                        <td class="col-http_response_code">${formatHttpResponseCode(service.http_response_code)}</td>
                        <td class="col-redirect_url">${service.redirect_url || '-'}</td>
                        <td class="col-port hidden">${service.port}</td>
                        <td class="col-protocol hidden">${service.protocol}</td>
                        <td class="col-service_type hidden">${service.service_type}</td>
                        <td class="col-cluster_ip hidden">${service.cluster_ip || 'N/A'}</td>
                        <td class="col-endpoint_status hidden">${service.endpoint_status}</td>
                        <td class="col-is_frontend hidden">${service.is_frontend}</td>
                        <td class="col-has_endpoints hidden">${service.has_endpoints}</td>
                        <td class="col-endpoint_count hidden">${service.endpoint_count}</td>
                        <td class="col-proxy_url hidden">${service.proxy_url}</td>
                        <td class="col-display_name hidden">${service.display_name}</td>
                        <td class="col-created_at hidden">${formatDateTime(service.created_at)}</td>
                    </tr>
                `;
            });

            tableBody.innerHTML = html;
            document.getElementById('table-container').style.display = 'block';
            document.getElementById('loading').style.display = 'none';
        }

        // Get status indicator
        function getStatusIndicator(service) {
            if (service.is_frontend) {
                return '<span class="status-indicator frontend-true">‚úÖ</span>';
            } else if (!service.has_endpoints || service.endpoint_status !== 'healthy') {
                return '<span class="status-indicator endpoints-false">‚ùå</span>';
            } else {
                return '<span class="status-indicator endpoints-true">‚úÖ</span>';
            }
        }

        // Setup field selector
        function setupFieldSelector() {
            const checkboxes = document.querySelectorAll('.field-checkbox input[type="checkbox"]');

            checkboxes.forEach(checkbox => {
                checkbox.addEventListener('change', function () {
                    const fieldName = this.id.replace('field-', '');

                    // Handle "All" checkbox
                    if (fieldName === 'all') {
                        const allCheckboxes = document.querySelectorAll('.field-checkbox input[type="checkbox"]:not(#field-all)');
                        const allColumns = document.querySelectorAll('th:not(.col-status), td:not(.col-status)');

                        if (this.checked) {
                            // Show all fields
                            allCheckboxes.forEach(cb => {
                                cb.checked = true;
                            });
                            allColumns.forEach(column => {
                                column.classList.remove('hidden');
                            });
                        } else {
                            // Revert to default view
                            revertToDefaultView();
                        }
                        return;
                    }

                    // Handle individual field checkboxes
                    const columns = document.querySelectorAll(`.col-${fieldName}`);

                    columns.forEach(column => {
                        if (this.checked) {
                            column.classList.remove('hidden');
                        } else {
                            column.classList.add('hidden');
                        }
                    });

                    // Update "All" checkbox state
                    updateAllCheckboxState();
                });
            });

            // Close field selector when clicking outside
            document.addEventListener('click', function (event) {
                const fieldSelector = document.getElementById('field-selector');
                const hamburgerButton = document.querySelector('.hamburger-button');

                if (!fieldSelector.contains(event.target) && !hamburgerButton.contains(event.target)) {
                    fieldSelector.classList.remove('show');
                }
            });
        }

        // Update "All" checkbox state based on individual checkboxes
        function updateAllCheckboxState() {
            const allCheckbox = document.getElementById('field-all');
            const individualCheckboxes = document.querySelectorAll('.field-checkbox input[type="checkbox"]:not(#field-all)');
            const checkedCount = Array.from(individualCheckboxes).filter(cb => cb.checked).length;

            if (checkedCount === 0) {
                allCheckbox.checked = false;
                allCheckbox.indeterminate = false;
            } else if (checkedCount === individualCheckboxes.length) {
                allCheckbox.checked = true;
                allCheckbox.indeterminate = false;
            } else {
                allCheckbox.checked = false;
                allCheckbox.indeterminate = true;
            }
        }

        // Revert to default view (show only the default fields)
        function revertToDefaultView() {
            const defaultFields = ['namespace', 'service', 'port_name', 'http_response_code', 'redirect_url'];
            const allCheckboxes = document.querySelectorAll('.field-checkbox input[type="checkbox"]:not(#field-all)');
            const allColumns = document.querySelectorAll('th:not(.col-status), td:not(.col-status)');

            // Reset all checkboxes to unchecked
            allCheckboxes.forEach(cb => {
                cb.checked = false;
            });

            // Hide all columns except status
            allColumns.forEach(column => {
                column.classList.add('hidden');
            });

            // Show only default fields
            defaultFields.forEach(fieldName => {
                const checkbox = document.getElementById(`field-${fieldName}`);
                if (checkbox) {
                    checkbox.checked = true;
                }
                const columns = document.querySelectorAll(`.col-${fieldName}`);
                columns.forEach(column => {
                    column.classList.remove('hidden');
                });
            });
        }

        // Toggle field selector
        function toggleFieldSelector() {
            const fieldSelector = document.getElementById('field-selector');
            fieldSelector.classList.toggle('show');
        }

        // Apply URL parameters on page load
        function applyUrlParameters() {
            const urlFilter = getUrlParameter('filter');
            const urlNamespace = getUrlParameter('namespace');

            // Apply filter if specified
            if (urlFilter && ['all', 'healthy', 'unhealthy', 'frontend'].includes(urlFilter)) {
                applyFilterFromUrl(urlFilter);
            }

            // Apply namespace if specified
            if (urlNamespace) {
                applyNamespaceFromUrl(urlNamespace);
            }
        }

        // Apply filter from URL parameter
        function applyFilterFromUrl(filterType) {
            currentFilter = filterType;

            // Update active state
            document.querySelectorAll('.stat-card').forEach(card => {
                card.classList.remove('active');
            });

            const targetCard = document.querySelector(`[data-filter="${filterType}"]`);
            if (targetCard) {
                targetCard.classList.add('active');
            }

            // Apply the filter
            applyCurrentFilters();
        }

        // Apply namespace from URL parameter
        function applyNamespaceFromUrl(namespace) {
            currentNamespace = namespace;

            // Update namespace dropdown
            const currentNamespaceSpan = document.getElementById('current-namespace');
            const namespaceOptions = document.getElementById('namespace-options');

            // Find and select the namespace option
            const namespaceOption = namespaceOptions.querySelector(`input[value="${namespace}"]`);
            if (namespaceOption) {
                namespaceOptions.querySelectorAll('.namespace-option').forEach(opt => opt.classList.remove('selected'));
                namespaceOption.closest('.namespace-option').classList.add('selected');
                currentNamespaceSpan.textContent = namespaceOption.closest('.namespace-option').querySelector('label').textContent;
            } else {
                // If namespace not found, default to "All"
                currentNamespaceSpan.textContent = 'All';
                namespaceOptions.querySelector('.namespace-option input[value="all"]').closest('.namespace-option').classList.add('selected');
            }

            // Apply the filter
            applyCurrentFilters();
        }

        // Filter namespace options based on search input
        function filterNamespaceOptions() {
            const searchInput = document.getElementById('namespace-search-input');
            const searchTerm = searchInput.value.toLowerCase();
            const namespaceOptions = document.querySelectorAll('.namespace-option');

            namespaceOptions.forEach(option => {
                const label = option.querySelector('label').textContent.toLowerCase();
                if (label.includes(searchTerm)) {
                    option.style.display = 'flex';
                } else {
                    option.style.display = 'none';
                }
            });
        }

        // Clear namespace search and show all options
        function clearNamespaceSearch() {
            const searchInput = document.getElementById('namespace-search-input');
            searchInput.value = '';
            filterNamespaceOptions();
        }

        // Setup namespace selector
        function setupNamespaceSelector() {
            if (!servicesData || !servicesData.meta || !servicesData.meta.namespaces_scanned) return;

            const namespaceOptions = document.getElementById('namespace-options');
            const namespaces = servicesData.meta.namespaces_scanned;

            // Add namespace options
            namespaces.forEach(namespace => {
                const option = document.createElement('div');
                option.className = 'namespace-option';
                option.innerHTML = `
                    <input type="radio" name="namespace" value="${namespace}">
                    <label>${namespace}</label>
                `;
                namespaceOptions.appendChild(option);
            });

            // Setup event listeners
            const namespaceSelector = document.getElementById('namespace-selector');
            const namespaceButton = document.querySelector('.namespace-button');
            const currentNamespaceSpan = document.getElementById('current-namespace');

            // Setup search input event listeners
            const namespaceSearchInput = document.getElementById('namespace-search-input');

            // Toggle dropdown
            namespaceButton.addEventListener('click', function (event) {
                event.stopPropagation();
                const isOpening = !namespaceSelector.classList.contains('show');

                namespaceSelector.classList.toggle('show');
                namespaceButton.classList.toggle('active');

                // Focus search input and clear search when opening
                if (isOpening) {
                    clearNamespaceSearch();
                    setTimeout(() => namespaceSearchInput.focus(), 100);
                }
            });

            // Handle keyboard navigation in search input
            namespaceSearchInput.addEventListener('keydown', function (event) {
                const visibleOptions = Array.from(document.querySelectorAll('.namespace-option'))
                    .filter(option => option.style.display !== 'none');

                switch (event.key) {
                    case 'ArrowDown':
                        event.preventDefault();
                        if (visibleOptions.length > 0) {
                            const firstOption = visibleOptions[0];
                            firstOption.classList.add('selected');
                            firstOption.querySelector('input').focus();
                        }
                        break;
                    case 'Enter':
                        event.preventDefault();
                        if (visibleOptions.length === 1) {
                            // If only one option is visible, select it
                            visibleOptions[0].click();
                        }
                        break;
                    case 'Escape':
                        event.preventDefault();
                        namespaceSelector.classList.remove('show');
                        namespaceButton.classList.remove('active');
                        this.blur();
                        break;
                }
            });

            // Handle namespace selection
            namespaceOptions.addEventListener('click', function (event) {
                const option = event.target.closest('.namespace-option');
                if (!option) return;

                // Update selected state
                namespaceOptions.querySelectorAll('.namespace-option').forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');

                // Update button text
                const selectedLabel = option.querySelector('label').textContent;
                currentNamespaceSpan.textContent = selectedLabel;

                // Filter by namespace
                const selectedValue = option.querySelector('input[type="radio"]').value;
                filterByNamespace(selectedValue);

                // Close dropdown
                namespaceSelector.classList.remove('show');
                namespaceButton.classList.remove('active');
            });

            // Close dropdown when clicking outside
            document.addEventListener('click', function (event) {
                if (!namespaceSelector.contains(event.target) && !namespaceButton.contains(event.target)) {
                    namespaceSelector.classList.remove('show');
                    namespaceButton.classList.remove('active');
                    clearNamespaceSearch();
                }
            });
        }

        // Apply current filters (combines both filter and namespace)
        function applyCurrentFilters() {
            // If advanced filters are active, use the advanced filter system
            const activeAdvancedFilters = advancedFilters.filter(rule => rule.value.trim() !== '');
            if (activeAdvancedFilters.length > 0) {
                applyAdvancedFilters();
                return;
            }

            const rows = document.querySelectorAll('tbody tr');

            rows.forEach(row => {
                const endpointStatus = row.dataset.endpointStatus;
                const isFrontend = row.dataset.isFrontend === 'true';
                const serviceNamespace = row.dataset.namespace;

                let show = true;

                // Apply filter
                switch (currentFilter) {
                    case 'all':
                        show = true;
                        break;
                    case 'healthy':
                        show = endpointStatus === 'healthy';
                        break;
                    case 'unhealthy':
                        show = endpointStatus === 'unhealthy';
                        break;
                    case 'frontend':
                        show = isFrontend;
                        break;
                    case 'namespaces':
                        show = true; // Namespace filtering handles this
                        break;
                }

                // Apply namespace filter
                if (show && currentNamespace !== 'all') {
                    show = serviceNamespace === currentNamespace;
                }

                if (show) {
                    row.classList.remove('filtered-out');
                } else {
                    row.classList.add('filtered-out');
                }
            });

            // Update URL parameters
            updateUrlParameters();
        }

        // Filter by namespace
        function filterByNamespace(namespace) {
            // Clear advanced filters when namespace is used
            clearAllFilters();

            // Reset stat card selections
            document.querySelectorAll('.stat-card').forEach(card => {
                card.classList.remove('active');
            });

            currentNamespace = namespace;
            currentFilter = 'namespaces'; // Override currentFilter for namespace filtering

            applyCurrentFilters();
        }

        // Filter by stat card
        function filterByStat(filterType) {
            // Clear advanced filters when stat cards are used
            clearAllFilters();

            // Update active state
            document.querySelectorAll('.stat-card').forEach(card => {
                card.classList.remove('active');
            });
            event.target.closest('.stat-card').classList.add('active');

            // Reset namespace filter
            const currentNamespaceSpan = document.getElementById('current-namespace');
            currentNamespaceSpan.textContent = 'All';
            document.querySelectorAll('.namespace-option').forEach(opt => opt.classList.remove('selected'));
            document.querySelector('.namespace-option input[value="all"]').closest('.namespace-option').classList.add('selected');

            currentFilter = filterType;
            currentNamespace = 'all';

            applyCurrentFilters();
        }

        // Advanced Filter Functions
        function toggleAdvancedFilter() {
            const filterPanel = document.getElementById('advanced-filter-panel');
            const filterButton = document.querySelector('.filter-button');

            filterPanel.classList.toggle('show');
            filterButton.classList.toggle('active');
        }

        function addFilterRule(column = 'namespace', operator = 'contains', value = '', logic = 'and') {
            filterRuleCounter++;
            const ruleId = `filter-rule-${filterRuleCounter}`;

            const rule = {
                id: ruleId,
                column: column,
                operator: operator,
                value: value,
                logic: logic
            };

            advancedFilters.push(rule);
            renderFilterRules();
            updateFilterActiveCount();

            // Show autocomplete for the new rule's column if it's empty
            if (!value) {
                setTimeout(() => {
                    showAutocompleteForColumn(ruleId, column);
                }, 100); // Small delay to ensure DOM is updated
            }
        }

        function removeFilterRule(ruleId) {
            advancedFilters = advancedFilters.filter(rule => rule.id !== ruleId);
            renderFilterRules();
            updateFilterActiveCount();
            applyAdvancedFilters();
        }

        function renderFilterRules() {
            const filterRulesContainer = document.getElementById('filter-rules');
            let html = '';

            const availableColumns = [
                { value: 'namespace', label: 'Namespace' },
                { value: 'service', label: 'Service' },
                { value: 'port_name', label: 'Port Name' },
                { value: 'port', label: 'Port' },
                { value: 'protocol', label: 'Protocol' },
                { value: 'service_type', label: 'Service Type' },
                { value: 'cluster_ip', label: 'Cluster IP' },
                { value: 'endpoint_status', label: 'Endpoint Status' },
                { value: 'display_name', label: 'Display Name' },
                { value: 'http_response_code', label: 'HTTP Response Code' },
                { value: 'redirect_url', label: 'Redirect Info' }
            ];

            const operators = [
                { value: 'contains', label: 'Contains' },
                { value: 'begins_with', label: 'Begins With' },
                { value: 'ends_with', label: 'Ends With' },
                { value: 'equals', label: 'Equals' }
            ];

            advancedFilters.forEach((rule, index) => {
                const showLogic = index > 0;

                html += `
                    <div class="filter-rule" data-rule-id="${rule.id}">
                        ${showLogic ? `
                            <div class="filter-logic">
                                <select onchange="updateFilterRule('${rule.id}', 'logic', this.value)">
                                    <option value="and" ${rule.logic === 'and' ? 'selected' : ''}>AND</option>
                                    <option value="or" ${rule.logic === 'or' ? 'selected' : ''}>OR</option>
                                </select>
                            </div>
                        ` : ''}
                        <select onchange="updateFilterRuleColumn('${rule.id}', this.value)">
                            ${availableColumns.map(col =>
                    `<option value="${col.value}" ${rule.column === col.value ? 'selected' : ''}>${col.label}</option>`
                ).join('')}
                        </select>
                        <select onchange="updateFilterRule('${rule.id}', 'operator', this.value)">
                            ${operators.map(op =>
                    `<option value="${op.value}" ${rule.operator === op.value ? 'selected' : ''}>${op.label}</option>`
                ).join('')}
                        </select>
                        <div class="autocomplete-container">
                            <input type="text" placeholder="Filter value..." value="${rule.value}" 
                                   oninput="updateFilterRule('${rule.id}', 'value', this.value)"
                                   onfocus="showAutocomplete('${rule.id}', '${rule.column}')"
                                   onkeydown="handleAutocompleteKeydown(event, '${rule.id}')"
                                   autocomplete="off">
                            <div class="autocomplete-suggestions" id="autocomplete-${rule.id}"></div>
                        </div>
                        <button class="filter-rule-remove" onclick="removeFilterRule('${rule.id}')">√ó</button>
                    </div>
                `;
            });

            filterRulesContainer.innerHTML = html;
        }

        function updateFilterRule(ruleId, property, value) {
            const rule = advancedFilters.find(r => r.id === ruleId);
            if (rule) {
                rule[property] = value;

                if (property === 'value') {
                    // Show autocomplete while typing
                    showAutocomplete(ruleId, rule.column);
                }

                applyAdvancedFilters();
            }
        }

        function updateFilterRuleColumn(ruleId, newColumn) {
            const rule = advancedFilters.find(r => r.id === ruleId);
            if (rule) {
                rule.column = newColumn;

                // Clear the input value when column changes
                const input = document.querySelector(`[data-rule-id="${ruleId}"] input`);
                if (input) {
                    input.value = '';
                    rule.value = '';
                }

                // Immediately show autocomplete for the new column (empty search)
                showAutocompleteForColumn(ruleId, newColumn);

                applyAdvancedFilters();
            }
        }

        function updateFilterActiveCount() {
            const activeCount = advancedFilters.filter(rule => rule.value.trim() !== '').length;
            const countElement = document.getElementById('filter-active-count');

            if (activeCount > 0) {
                countElement.textContent = activeCount;
                countElement.style.display = 'inline';
                document.querySelector('.filter-button').classList.add('active');
            } else {
                countElement.style.display = 'none';
                document.querySelector('.filter-button').classList.remove('active');
            }
        }

        function clearAllFilters() {
            advancedFilters = [];
            renderFilterRules();
            updateFilterActiveCount();
            updateAdvancedFilterUrl();

            // Only apply filters if we're not in the middle of another filter operation
            if (typeof event === 'undefined' || !event.target?.closest('.stat-card, .namespace-option')) {
                applyAdvancedFilters();
            }
        }

        function applyAdvancedFilters() {
            if (!servicesData || !servicesData.services) return;

            const rows = document.querySelectorAll('tbody tr');

            rows.forEach(row => {
                let show = true;

                // Apply advanced filters first
                if (advancedFilters.length > 0) {
                    show = evaluateAdvancedFilters(row);
                }

                // Then apply namespace filter if no advanced filters are active
                if (show && advancedFilters.filter(rule => rule.value.trim() !== '').length === 0) {
                    // Apply existing filters (stat cards and namespace)
                    const endpointStatus = row.dataset.endpointStatus;
                    const isFrontend = row.dataset.isFrontend === 'true';
                    const serviceNamespace = row.dataset.namespace;

                    // Apply filter
                    switch (currentFilter) {
                        case 'all':
                            show = true;
                            break;
                        case 'healthy':
                            show = endpointStatus === 'healthy';
                            break;
                        case 'unhealthy':
                            show = endpointStatus === 'unhealthy';
                            break;
                        case 'frontend':
                            show = isFrontend;
                            break;
                        case 'namespaces':
                            show = true; // Namespace filtering handles this
                            break;
                    }

                    // Apply namespace filter
                    if (show && currentNamespace !== 'all') {
                        show = serviceNamespace === currentNamespace;
                    }
                }

                if (show) {
                    row.classList.remove('filtered-out');
                } else {
                    row.classList.add('filtered-out');
                }
            });

            updateAdvancedFilterUrl();
        }

        function evaluateAdvancedFilters(row) {
            if (advancedFilters.length === 0) return true;

            const activeFilters = advancedFilters.filter(rule => rule.value.trim() !== '');
            if (activeFilters.length === 0) return true;

            let result = evaluateFilterRule(activeFilters[0], row);

            for (let i = 1; i < activeFilters.length; i++) {
                const rule = activeFilters[i];
                const ruleResult = evaluateFilterRule(rule, row);

                if (rule.logic === 'and') {
                    result = result && ruleResult;
                } else {
                    result = result || ruleResult;
                }
            }

            return result;
        }

        function evaluateFilterRule(rule, row) {
            let cellValue = '';

            // Get the cell value based on column
            const cells = row.querySelectorAll('td');
            switch (rule.column) {
                case 'namespace':
                    cellValue = row.dataset.namespace || '';
                    break;
                case 'service':
                    cellValue = cells[2]?.textContent || '';
                    break;
                case 'port_name':
                    cellValue = cells[3]?.textContent || '';
                    break;
                case 'http_response_code':
                    cellValue = cells[4]?.textContent || '';
                    break;
                case 'redirect_url':
                    cellValue = cells[5]?.textContent || '';
                    break;
                case 'port':
                    cellValue = cells[6]?.textContent || '';
                    break;
                case 'protocol':
                    cellValue = cells[7]?.textContent || '';
                    break;
                case 'service_type':
                    cellValue = cells[8]?.textContent || '';
                    break;
                case 'cluster_ip':
                    cellValue = cells[9]?.textContent || '';
                    break;
                case 'endpoint_status':
                    cellValue = row.dataset.endpointStatus || '';
                    break;
                case 'display_name':
                    cellValue = cells[13]?.textContent || '';
                    break;
                default:
                    cellValue = '';
            }

            const filterValue = rule.value.toLowerCase();
            const targetValue = cellValue.toLowerCase();

            switch (rule.operator) {
                case 'contains':
                    return targetValue.includes(filterValue);
                case 'begins_with':
                    return targetValue.startsWith(filterValue);
                case 'ends_with':
                    return targetValue.endsWith(filterValue);
                case 'equals':
                    return targetValue === filterValue;
                default:
                    return true;
            }
        }

        function updateAdvancedFilterUrl() {
            const url = new URL(window.location);

            // Clear existing advanced filter parameters
            const paramsToRemove = [];
            for (const [key] of url.searchParams) {
                if (key.startsWith('af_') || key.startsWith('filter_rule')) {
                    paramsToRemove.push(key);
                }
            }
            paramsToRemove.forEach(param => url.searchParams.delete(param));

            // Add current advanced filter parameters
            const activeFilters = advancedFilters.filter(rule => rule.value.trim() !== '');
            activeFilters.forEach((rule, index) => {
                const prefix = `af_${index}`;
                url.searchParams.set(`${prefix}_column`, rule.column);
                url.searchParams.set(`${prefix}_operator`, rule.operator);
                url.searchParams.set(`${prefix}_value`, rule.value);
                if (index > 0) {
                    url.searchParams.set(`${prefix}_logic`, rule.logic);
                }
            });

            window.history.replaceState({}, '', url);
        }

        function loadAdvancedFiltersFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const filters = [];

            // Look for advanced filter parameters
            let index = 0;
            while (true) {
                const prefix = `af_${index}`;
                const column = urlParams.get(`${prefix}_column`);
                const operator = urlParams.get(`${prefix}_operator`);
                const value = urlParams.get(`${prefix}_value`);

                if (!column || !operator || !value) break;

                const logic = index > 0 ? urlParams.get(`${prefix}_logic`) || 'and' : 'and';

                filters.push({
                    column: column,
                    operator: operator,
                    value: value,
                    logic: logic
                });

                index++;
            }

            // Load filters if found
            if (filters.length > 0) {
                advancedFilters = [];
                filters.forEach(filter => {
                    addFilterRule(filter.column, filter.operator, filter.value, filter.logic);
                });
                applyAdvancedFilters();
            }
        }

        // Autocomplete functionality
        let currentAutocompleteIndex = -1;
        let currentAutocompleteSuggestions = [];

        function getColumnValues(column) {
            if (!servicesData || !servicesData.services) return [];

            const values = new Set();

            servicesData.services.forEach(service => {
                let value = '';
                switch (column) {
                    case 'namespace':
                        value = service.namespace;
                        break;
                    case 'service':
                        value = service.service;
                        break;
                    case 'port_name':
                        value = service.port_name || '';
                        break;
                    case 'port':
                        value = service.port?.toString() || '';
                        break;
                    case 'protocol':
                        value = service.protocol;
                        break;
                    case 'service_type':
                        value = service.service_type;
                        break;
                    case 'cluster_ip':
                        value = service.cluster_ip || '';
                        break;
                    case 'endpoint_status':
                        value = service.endpoint_status;
                        break;
                    case 'display_name':
                        value = service.display_name;
                        break;
                    case 'http_response_code':
                        value = service.http_response_code?.toString() || '';
                        break;
                    case 'redirect_url':
                        value = service.redirect_url || '';
                        break;
                }
                if (value) values.add(value);
            });

            return Array.from(values).sort();
        }

        function showAutocomplete(ruleId, column) {
            const input = document.querySelector(`[data-rule-id="${ruleId}"] input`);
            const suggestionsContainer = document.getElementById(`autocomplete-${ruleId}`);

            if (!input || !suggestionsContainer) return;

            const inputValue = input.value.toLowerCase();
            const allValues = getColumnValues(column);

            // Filter values based on current input
            const filteredValues = allValues.filter(value =>
                value.toLowerCase().includes(inputValue)
            ).slice(0, 10); // Limit to 10 suggestions

            currentAutocompleteSuggestions = filteredValues;
            currentAutocompleteIndex = -1;

            if (filteredValues.length === 0) {
                suggestionsContainer.innerHTML = '<div class="autocomplete-no-results">No matches found</div>';
                suggestionsContainer.classList.add('show');
                return;
            }

            const suggestionsHtml = filteredValues.map((value, index) =>
                `<div class="autocomplete-suggestion" onclick="selectAutocompleteSuggestion('${ruleId}', '${value.replace(/'/g, "\\'")}')" 
                     data-index="${index}">${value}</div>`
            ).join('');

            suggestionsContainer.innerHTML = suggestionsHtml;
            suggestionsContainer.classList.add('show');
        }

        function showAutocompleteForColumn(ruleId, column) {
            const suggestionsContainer = document.getElementById(`autocomplete-${ruleId}`);

            if (!suggestionsContainer) return;

            const allValues = getColumnValues(column);

            // Show all values for the new column (limit to 10 for performance)
            const displayValues = allValues.slice(0, 10);

            currentAutocompleteSuggestions = displayValues;
            currentAutocompleteIndex = -1;

            if (displayValues.length === 0) {
                suggestionsContainer.innerHTML = '<div class="autocomplete-no-results">No values available</div>';
                suggestionsContainer.classList.add('show');
                return;
            }

            const suggestionsHtml = displayValues.map((value, index) =>
                `<div class="autocomplete-suggestion" onclick="selectAutocompleteSuggestion('${ruleId}', '${value.replace(/'/g, "\\'")}')" 
                     data-index="${index}">${value}</div>`
            ).join('');

            suggestionsContainer.innerHTML = suggestionsHtml;
            suggestionsContainer.classList.add('show');
        }

        function selectAutocompleteSuggestion(ruleId, value) {
            const input = document.querySelector(`[data-rule-id="${ruleId}"] input`);
            const suggestionsContainer = document.getElementById(`autocomplete-${ruleId}`);

            if (input) {
                input.value = value;
                updateFilterRule(ruleId, 'value', value);
            }

            if (suggestionsContainer) {
                suggestionsContainer.classList.remove('show');
            }

            currentAutocompleteIndex = -1;
            currentAutocompleteSuggestions = [];
        }

        function handleAutocompleteKeydown(event, ruleId) {
            const suggestionsContainer = document.getElementById(`autocomplete-${ruleId}`);

            if (!suggestionsContainer || !suggestionsContainer.classList.contains('show')) return;

            const suggestions = suggestionsContainer.querySelectorAll('.autocomplete-suggestion');

            switch (event.key) {
                case 'ArrowDown':
                    event.preventDefault();
                    currentAutocompleteIndex = Math.min(currentAutocompleteIndex + 1, suggestions.length - 1);
                    updateAutocompleteHighlight(suggestions);
                    break;

                case 'ArrowUp':
                    event.preventDefault();
                    currentAutocompleteIndex = Math.max(currentAutocompleteIndex - 1, -1);
                    updateAutocompleteHighlight(suggestions);
                    break;

                case 'Enter':
                    event.preventDefault();
                    if (currentAutocompleteIndex >= 0 && suggestions[currentAutocompleteIndex]) {
                        const selectedValue = currentAutocompleteSuggestions[currentAutocompleteIndex];
                        selectAutocompleteSuggestion(ruleId, selectedValue);
                    }
                    break;

                case 'Escape':
                    event.preventDefault();
                    suggestionsContainer.classList.remove('show');
                    currentAutocompleteIndex = -1;
                    break;
            }
        }

        function updateAutocompleteHighlight(suggestions) {
            suggestions.forEach((suggestion, index) => {
                if (index === currentAutocompleteIndex) {
                    suggestion.classList.add('highlighted');
                } else {
                    suggestion.classList.remove('highlighted');
                }
            });
        }

        function hideAllAutocomplete() {
            document.querySelectorAll('.autocomplete-suggestions').forEach(container => {
                container.classList.remove('show');
            });
            currentAutocompleteIndex = -1;
            currentAutocompleteSuggestions = [];
        }

        function setupAdvancedFilter() {
            // Close filter panel when clicking outside
            document.addEventListener('click', function (event) {
                const filterPanel = document.getElementById('advanced-filter-panel');
                const filterButton = document.querySelector('.filter-button');

                if (!filterPanel.contains(event.target) && !filterButton.contains(event.target)) {
                    filterPanel.classList.remove('show');
                    filterButton.classList.remove('active');
                }

                // Hide autocomplete when clicking outside
                if (!event.target.closest('.autocomplete-container')) {
                    hideAllAutocomplete();
                }
            });
        }

        // Service opening functionality
        function openService(proxyUrl, redirectUrl) {
            if (proxyUrl && proxyUrl !== 'N/A') {
                let targetUrl = proxyUrl;

                // If redirect_url starts with "/", append it to the proxy URL
                if (redirectUrl && redirectUrl.startsWith('/')) {
                    // Remove trailing slash from proxy URL and append redirect path
                    targetUrl = proxyUrl.replace(/\/$/, '') + redirectUrl;
                }

                window.open(targetUrl, '_self');
            }
        }

        // Cookie clearing functionality
        function clearCookies() {
            const currentDomain = window.location.hostname;
            const currentProtocol = window.location.protocol;
            const currentPort = window.location.port;
            let clearedCount = 0;

            // Method 1: Clear all cookies from document.cookie
            const cookies = document.cookie.split(';');
            cookies.forEach(cookie => {
                const eqPos = cookie.indexOf('=');
                if (eqPos > 0) {
                    const name = cookie.substring(0, eqPos).trim();
                    clearedCount += clearCookieForcefully(name, currentDomain, currentPort);
                }
            });

            // Method 2: Try to clear common cookie names that might be set by services
            const commonCookieNames = [
                'session', 'sessionid', 'sess', 'auth', 'token', 'jwt', 'csrf', 'xsrf',
                'PHPSESSID', 'JSESSIONID', 'ASP.NET_SessionId', 'connect.sid',
                'remember_me', 'user_id', 'userid', 'uid', 'login', 'logged_in',
                'admin', 'admin_session', 'admin_token', 'admin_auth',
                'oauth', 'oauth_token', 'access_token', 'refresh_token',
                'k8s', 'kubernetes', 'kubeconfig', 'kubectl',
                'dashboard', 'portal', 'porthole', 'service', 'namespace'
            ];

            commonCookieNames.forEach(name => {
                clearedCount += clearCookieForcefully(name, currentDomain, currentPort);
            });

            // Method 3: Clear localStorage and sessionStorage
            try {
                localStorage.clear();
                sessionStorage.clear();
                console.log('Cleared localStorage and sessionStorage');
            } catch (e) {
                console.log('Could not clear localStorage/sessionStorage:', e);
            }

            // Method 4: Try to clear IndexedDB
            if ('indexedDB' in window) {
                indexedDB.databases().then(databases => {
                    databases.forEach(db => {
                        indexedDB.deleteDatabase(db.name);
                    });
                    console.log('Cleared IndexedDB databases');
                }).catch(e => {
                    console.log('Could not clear IndexedDB:', e);
                });
            }

            // Show feedback to user
            const button = event.target.closest('.cookie-clear-button');
            const originalText = button.innerHTML;
            button.innerHTML = '‚úÖ Cleared!';
            button.style.background = 'rgba(76, 175, 80, 0.3)';
            button.style.borderColor = 'rgba(76, 175, 80, 0.5)';
            button.style.color = '#4caf50';

            // Reset button after 3 seconds
            setTimeout(() => {
                button.innerHTML = originalText;
                button.style.background = 'rgba(255, 152, 0, 0.2)';
                button.style.borderColor = 'rgba(255, 152, 0, 0.3)';
                button.style.color = '#ff9800';
            }, 3000);

            console.log(`Cleared ${clearedCount} cookies and storage for domain: ${currentDomain}`);
        }

        // Helper function to clear a cookie with multiple strategies
        function clearCookieForcefully(name, domain, port) {
            let clearedCount = 0;
            const expirationDate = 'Thu, 01 Jan 1970 00:00:00 GMT';
            
            // Strategy 1: Basic clear with path=/
            document.cookie = `${name}=; expires=${expirationDate}; path=/`;
            clearedCount++;
            
            // Strategy 2: Clear with domain
            if (domain) {
                document.cookie = `${name}=; expires=${expirationDate}; path=/; domain=${domain}`;
                clearedCount++;
            }
            
            // Strategy 3: Clear with .domain (for subdomains)
            if (domain && domain.includes('.')) {
                document.cookie = `${name}=; expires=${expirationDate}; path=/; domain=.${domain}`;
                clearedCount++;
            }
            
            // Strategy 4: Clear with parent domain
            if (domain && domain.includes('.')) {
                const domainParts = domain.split('.');
                if (domainParts.length > 1) {
                    const parentDomain = domainParts.slice(-2).join('.');
                    document.cookie = `${name}=; expires=${expirationDate}; path=/; domain=.${parentDomain}`;
                    clearedCount++;
                }
            }
            
            // Strategy 5: Clear with specific paths
            const paths = ['/', '/admin', '/api', '/auth', '/dashboard', '/portal', '/porthole'];
            paths.forEach(path => {
                document.cookie = `${name}=; expires=${expirationDate}; path=${path}`;
                clearedCount++;
            });
            
            // Strategy 6: Clear with secure flag if on HTTPS
            if (window.location.protocol === 'https:') {
                document.cookie = `${name}=; expires=${expirationDate}; path=/; secure`;
                clearedCount++;
            }
            
            // Strategy 7: Clear with httpOnly flag (though this won't work for httpOnly cookies)
            document.cookie = `${name}=; expires=${expirationDate}; path=/; httpOnly`;
            clearedCount++;
            
            return clearedCount;
        }

        // Initialize the page
        document.addEventListener('DOMContentLoaded', function () {
            loadServicesData();
        });
    </script>
</body>

</html>